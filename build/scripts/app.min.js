var app =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="./../../typings/tsd.d.ts" />
	"use strict";
	
	var markerAggregator_ts_1 = __webpack_require__(1);
	var map;
	var test;
	(function (context) {
	    'use strict';
	    // calculate markers center
	
	    var avgLat = 0,
	        avgLng = 0;
	    for (var i = 0; i < points.length; i++) {
	        avgLat += +points[i].lat;
	        avgLng += +points[i].lng;
	    }
	    avgLat /= points.length;
	    avgLng /= points.length;
	    document.addEventListener('DOMContentLoaded', function () {
	        // display map
	        map = L.map('map').setView([avgLat, avgLng], 12);
	        L.tileLayer.provider('OpenStreetMap.HOT').addTo(map);
	        // instantiate aggregator
	        test = new markerAggregator_ts_1.MarkerAggregator(map, {});
	        // var tree: ID2Tree<MarkerType> = new D2tree({lat: points[0].lat, lng: points[0].lng},
	        //                     [L.marker([points[0].lat, points[0].lng]),0]);
	        for (var i = 1; i < points.length; i++) {
	            // some noise to prevent marker overlapping
	            test.addNewMarker({
	                lat: points[i].lat + (Math.random() - 0.5) / 10000,
	                lng: points[i].lng + (Math.random() - 0.5) / 10000
	            }, points[i]);
	        }
	        test.start();
	        // console.log(points);
	        // var q = test.getBaseMarkers();
	        // console.log(q);
	        // var j=0;
	        // document.addEventListener('click', () => {
	        //     console.log(j);
	        //     // if (j < q.length) {
	        //     //     if (q[j]) q[j].marker.addTo(map);
	        //     // } else {alert('q');}
	        //     // j++;
	        //     if (j <points.length) {
	        //         test.addMarker({lat: points[j].lat, lng: points[j].lng});
	        //         j++;
	        //     }
	        // });
	        // for (var j=0; j < q.length; j++) {
	        //     // if (q[j]) console.log(q[j].getValue()[0]);
	        //     if (q[j]) q[j].marker.addTo(map);
	        // }
	        // console.log(test.getBaseMarkers());
	        // context.tree = tree;  
	        context.test = test;
	        context.map = map;
	    });
	})(window);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="./../../typings/tsd.d.ts" />
	/* global L */
	"use strict";
	
	var D2tree_ts_1 = __webpack_require__(2);
	// (function(context){
	// 'use strict';
	var MarkerAggregator = function () {
	    function MarkerAggregator(map, options) {
	        // assume L to be a global var
	        if (!L.version) console.error('Can\'t find Leaflet library');
	        if (options) {
	            this._map = map;
	            this._baseZoom = options.baseZoom || 15;
	            this._zoomStep = options.zoomStep || 1;
	            this._minZoom = options.minZoom || 5;
	            this._minZoom = this._baseZoom - (this._baseZoom - this._minZoom) / 2 * 2;
	            this._baseWindowSize = options.baseWindowSize || 0.008;
	        }
	        this._id = 0;
	        this._eastSouth = null;
	        this._baseMarkers = [];
	        this._baseMarkersTree = null;
	        this._zoomLevels = [];
	        // set up filter, disabled by default
	        this._filter = {
	            buyVal: -1,
	            sellVal: -1,
	            rad: false,
	            center: { lat: 0, lng: 0 },
	            radVal: 10
	        };
	        this._resetZoomLevels();
	        this._setCurrentZoomLevel();
	    }
	    // remove all composite markers
	    MarkerAggregator.prototype._resetZoomLevels = function () {
	        for (var j = this._baseZoom; j >= this._minZoom; j -= this._zoomStep) {
	            this._zoomLevels[j] = {
	                windowSize: this._baseWindowSize * Math.pow(1.7, this._baseZoom - j),
	                compositeMarkersTree: null
	            };
	        }
	    };
	    /*** calculate what set of markers (zoomLevel) to display based on the current map zoom */
	    MarkerAggregator.prototype._setCurrentZoomLevel = function () {
	        var mapZoom = this._map.getZoom();
	        if (mapZoom <= this._minZoom) {
	            this._currentZoomLevel = this._minZoom;
	        } else if (mapZoom >= this._baseZoom) {
	            this._currentZoomLevel = this._baseZoom;
	        } else {
	            this._currentZoomLevel = this._baseZoom - Math.floor((this._baseZoom - mapZoom) / 2) * 2;
	        }
	    };
	    /*** zoom in by zoom step */
	    MarkerAggregator.prototype._zoomin = function (coords) {
	        this._map.setView(coords, this._currentZoomLevel + this._zoomStep);
	    };
	    /*** when first marker is added iterate over all zoom levels and create trees
	     * to minimize computing expenses don't recalculate composite marker position
	     * just change it's content - if there is no base markers in it make it null
	    */
	    MarkerAggregator.prototype._createCompositeMarkers = function (coords, baseMarker) {
	        var _this = this;
	        var baseZoom = this._baseZoom,
	            zoomStep = this._zoomStep,
	            minZoom = this._minZoom,
	            zoomLevels = this._zoomLevels;
	        // apply changes to corresponding composite markers
	        var latIndex, lngIndex;
	        var compositeMarkerRef;
	        var nearest;
	        var compositeMarker;
	        // var compositeIcon = L.divIcon({html: '<div class="composite-icon"><p>qq</p></div>'});
	        // for every zoom level
	        for (var j = minZoom; j < baseZoom; j += zoomStep) {
	            if (!zoomLevels[j].compositeMarkersTree) {
	                // no composites yet
	                // create c marker
	                compositeMarker = {
	                    marker: L.marker([coords.lat, coords.lng], { icon: L.divIcon({ html: '<div class="composite-icon"><p>1</p></div>' }) }).on("click", this._zoomin).bindLabel(baseMarker.buy + ' / ' + baseMarker.sell, { noHide: true }),
	                    refs: [baseMarker]
	                };
	                // create a tree with this c marker
	                zoomLevels[j].compositeMarkersTree = new D2tree_ts_1.D2tree(coords, compositeMarker);
	            } else {
	                // search for the nearest composite on this zoom level
	                nearest = zoomLevels[j].compositeMarkersTree.findNearest(baseMarker.marker.getLatLng());
	                // within the radius of windowSize
	                if (nearest.dist <= zoomLevels[j].windowSize) {
	                    // if exists, add a link to the new base marker
	                    // but first remove from the map if necessary
	                    if (j === this._currentZoomLevel) {
	                        this._map.removeLayer(nearest.content.marker);
	                    }
	                    compositeMarker = nearest.content;
	                    compositeMarker.refs.push(baseMarker);
	                    // recalculate marker position
	                    // important! in order to avoid recalculating the whole tree
	                    // lat and lng of the tree node stays the same
	                    // but how it is displayed to the user changes
	                    compositeMarker.marker = L.marker([compositeMarker.refs.reduce(function (pv, cv) {
	                        return pv + cv.marker.getLatLng().lat;
	                    }, 0) / compositeMarker.refs.length, compositeMarker.refs.reduce(function (pv, cv) {
	                        return pv + cv.marker.getLatLng().lng;
	                    }, 0) / compositeMarker.refs.length], { icon: L.divIcon({ html: "<div class=\"composite-icon\"><p>" + compositeMarker.refs.length + "</p></div>" }) });
	                    compositeMarker.buy = compositeMarker.refs.reduce(function (pv, cv) {
	                        return cv.buy < pv ? cv.buy : pv;
	                    }, compositeMarker.refs[0].buy);
	                    compositeMarker.sell = compositeMarker.refs.reduce(function (pv, cv) {
	                        return cv.sell > pv ? cv.sell : pv;
	                    }, compositeMarker.refs[0].sell);
	                    compositeMarker.marker.bindLabel(compositeMarker.buy + ' / ' + baseMarker.sell, { noHide: true });
	                } else {
	                    // if not, create a new c marker
	                    compositeMarker = {
	                        marker: L.marker([coords.lat, coords.lng], {
	                            icon: L.divIcon({ html: '<div class="composite-icon"><p>1</p></div>' })
	                        }).bindLabel(baseMarker.buy + ' / ' + baseMarker.sell, { noHide: true }),
	                        refs: [baseMarker]
	                    };
	                    // add to the tree
	                    zoomLevels[j].compositeMarkersTree.addLeaf(coords, compositeMarker);
	                }
	            }
	            // click handler
	            compositeMarker.marker.on("click", function () {
	                _this._zoomin(compositeMarker.marker.getLatLng());
	            }, this);
	            // link base marker to it
	            // !!! mutating method argument, circular linking !!!
	            baseMarker.refs.push(compositeMarker);
	            // if necessary, show on the map
	            if (j === this._currentZoomLevel) {
	                compositeMarker.marker.addTo(this._map);
	            }
	        }
	    };
	    /** checks whether base marker is removed by current filter settings */
	    MarkerAggregator.prototype._checkFilter = function (marker) {
	        if (marker.buy < this._filter.buyVal) return false;
	        if (marker.sell > this._filter.sellVal) return false;
	        if (this._filter.rad && marker.marker.getLatLng().distanceTo(this._filter.center) > this._filter.radVal) return false;
	        return true;
	    };
	    /** external interface for adding markers
	     * @coords - marker coordinates either PointType or [lat, lng]
	     * @return - base marker id
	    */
	    MarkerAggregator.prototype.addNewMarker = function (coords, bankData) {
	        var localCoords = { lat: 0, lng: 0 };
	        var tempNum;
	        // read coordinates
	        if (Array.isArray(coords) && coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
	            localCoords.lat = coords[0];
	            localCoords.lng = coords[1];
	        } else if ((coords.lat || coords.lat === 0) && (coords.lng || coords.lng === 0)) {
	            localCoords.lat = coords.lat;
	            localCoords.lng = coords.lng;
	        } else {
	            return -1;
	        }
	        // check prices
	        if (bankData.buy && bankData.sell) {
	            // check the same bank
	            if (this._baseMarkers.reduce(function (pv, cv) {
	                if (!pv && (cv.bankName !== bankData.bankName || cv.address !== bankData.address)) return false;else return true;
	            }, false)) return undefined;
	            // create leaf content - marker
	            var marker = {
	                marker: L.marker([localCoords.lat, localCoords.lng]),
	                aId: ++this._id,
	                refs: [],
	                buy: bankData.buy,
	                sell: bankData.sell,
	                bankName: bankData.bankName,
	                address: bankData.address
	            };
	            // reset filter if necessary
	            tempNum = Math.floor((bankData.buy - 0.01) * 10) / 10;
	            if (this._filter.buyVal > tempNum || this._filter.buyVal < 0) {
	                this._filter.buyVal = tempNum;
	            }
	            tempNum = Math.ceil((+bankData.sell + 0.01) * 10) / 10;
	            if (this._filter.sellVal < tempNum || this._filter.sellVal < 0) {
	                this._filter.sellVal = tempNum;
	            }
	            this._baseMarkers.push(marker);
	            // text info on the markers
	            marker.marker.bindPopup((bankData.bankName ? '<p>' + bankData.bankName + '</p>' : '') + (bankData.address ? '<p>' + bankData.address + '</p>' : '') + (bankData.tel ? '<p>' + bankData.tel + '</p>' : '') + (bankData.wh ? '<p>' + bankData.wh + '</p>' : '') + (bankData.info ? '<p style="color: red;">' + bankData.info + '</p>' : '')).bindLabel(bankData.buy + ' / ' + bankData.sell, { noHide: true });
	            this._addMarker(marker);
	            return marker.aId;
	        } else {
	            return undefined;
	        }
	    };
	    /*** add new marker to the displayed ones
	     * @localCoords - base marker coordinates
	     * @marker - base marker
	    */
	    MarkerAggregator.prototype._addMarker = function (marker) {
	        var localCoords = marker.marker.getLatLng();
	        // this tree of no use now, maybee for the future
	        // if it's the first marker inserted
	        if (!this._baseMarkersTree) {
	            this._baseMarkersTree = new D2tree_ts_1.D2tree(localCoords, marker);
	            // link zoomLevels[baseZoom] to the baseMarkerTree for the sake of rerender method simplicity
	            this._zoomLevels[this._baseZoom].compositeMarkersTree = this._baseMarkersTree;
	        } else {
	            this._baseMarkersTree.addLeaf(localCoords, marker);
	        }
	        this._createCompositeMarkers(localCoords, marker);
	        // if zoom is big enough display base markers
	        if (this._baseZoom - this._zoomStep < this._currentZoomLevel) {
	            marker.marker.addTo(this._map);
	        }
	        //
	    };
	    /*** reset filter and recalculate*/
	    MarkerAggregator.prototype.filter = function (newFilter) {
	        var _this = this;
	        var i;
	        // better use Object assign
	        this._filter = {
	            buyVal: newFilter.buyVal ? newFilter.buyVal : this._filter.buyVal,
	            sellVal: newFilter.sellVal ? newFilter.sellVal : this._filter.sellVal,
	            rad: newFilter.rad ? true : false,
	            center: newFilter.center ? newFilter.center : this._filter.center,
	            radVal: newFilter.radVal ? newFilter.radVal : this._filter.radVal
	        };
	        // hide old markers
	        var oldMarkers = this._zoomLevels[this._currentZoomLevel].compositeMarkersTree.traverse();
	        for (i = 0; i < oldMarkers.length; i++) {
	            this._map.removeLayer(oldMarkers[i].marker);
	        }
	        // remove old markers
	        this._resetZoomLevels();
	        this._baseMarkersTree = null;
	        var markersLeft = this._baseMarkers.filter(function (e) {
	            return _this._checkFilter(e);
	        });
	        for (i = 0; i < markersLeft.length; i++) {
	            this._addMarker(markersLeft[i]);
	        }
	    };
	    /*** return base markers */
	    MarkerAggregator.prototype.getBaseMarkers = function () {
	        return this._baseMarkersTree.traverse();
	    };
	    /*** redraw markers on the map */
	    MarkerAggregator.prototype._rerender = function () {
	        // console.log('inside rerender');
	        var tmpLMarkers;
	        var j;
	        // store old zoom level and calculate new one
	        var oldZoom = this._currentZoomLevel;
	        this._setCurrentZoomLevel();
	        if (this._zoomLevels[this._currentZoomLevel] && this._zoomLevels[this._currentZoomLevel] !== this._zoomLevels[oldZoom]) {
	            // if new zoom level exists and is not the same as the previous
	            tmpLMarkers = this._zoomLevels[oldZoom].compositeMarkersTree.traverse();
	            // remove old markers from the map
	            for (j = 0; j < tmpLMarkers.length; j++) {
	                this._map.removeLayer(tmpLMarkers[j].marker);
	            }
	            tmpLMarkers = this._zoomLevels[this._currentZoomLevel].compositeMarkersTree.traverse();
	            // add new markers
	            for (j = 0; j < tmpLMarkers.length; j++) {
	                tmpLMarkers[j].marker.addTo(this._map);
	            }
	        } else {}
	    };
	    /*** start listen for map's zoom change */
	    MarkerAggregator.prototype.start = function () {
	        // take care not to call rerender many times
	        this.stop();
	        console.log('inside start');
	        this._map.on('zoomend', this._rerender, this);
	        // initialize
	        this._rerender();
	    };
	    /*** stop listen for map's zoom change */
	    MarkerAggregator.prototype.stop = function () {
	        console.log('inside stop');
	        this._map.off('zoomend', this._rerender, this);
	    };
	    return MarkerAggregator;
	}();
	exports.MarkerAggregator = MarkerAggregator;
	// inject
	// 	context.MarkerAggregator = MarkerAggregator;
	// }(window));

/***/ },
/* 2 */
/***/ function(module, exports) {

	/// <reference path="./../../typings/tsd.d.ts" />
	"use strict";
	
	var Node = function () {
	    function Node(coords, content) {
	        // coords either Ilatlng or [lat, lng]
	        // read coordinates
	        if (Array.isArray(coords) && coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
	            this._latKey = coords[0];
	            this._lngKey = coords[1];
	        } else if ((coords.lat || coords.lat === 0) && (coords.lng || coords.lng === 0)) {
	            this._latKey = coords.lat;
	            this._lngKey = coords.lng;
	        } else {
	            console.error('D2tree - Node: wrong node coordinates');
	            this._latKey = 0;
	            this._lngKey = 0;
	        }
	        // no branches
	        this._leftNode = null;
	        this._rightNode = null;
	        // by default red
	        this._color = true;
	        this._content = content;
	    }
	    Node.prototype.setLeftNode = function (node) {
	        this._leftNode = node;
	        return this._leftNode;
	    };
	    Node.prototype.setRightNode = function (node) {
	        this._rightNode = node;
	        return this._rightNode;
	    };
	    Node.prototype.getLeftNode = function () {
	        return this._leftNode;
	    };
	    Node.prototype.getRightNode = function () {
	        return this._rightNode;
	    };
	    Node.prototype.setColor = function (color) {
	        if (color) this._color = true;else this._color = false;
	    };
	    Node.prototype.getColor = function () {
	        return this._color;
	    };
	    Node.prototype.getLat = function () {
	        return this._latKey;
	    };
	    Node.prototype.getLng = function () {
	        return this._lngKey;
	    };
	    Node.prototype.getContent = function () {
	        return this._content;
	    };
	    return Node;
	}();
	var D2tree = function () {
	    function D2tree(coords, content) {
	        this._root = new Node(coords, content);
	    }
	    D2tree.prototype._place = function (parentNode, childNode) {
	        var method;
	        var direction;
	        if (parentNode.getColor()) {
	            // RED - lng
	            method = 'getLng';
	        } else {
	            // BLACK - lat
	            method = 'getLat';
	        }
	        if (parentNode[method]() < childNode[method]()) {
	            // new to right
	            direction = 'RightNode';
	        } else {
	            // new to left
	            direction = 'LeftNode';
	        }
	        if (!parentNode["get" + direction]()) {
	            // branch is empty
	            parentNode["set" + direction](childNode);
	            parentNode["get" + direction]().setColor(!parentNode.getColor());
	        } else {
	            this._place(parentNode["get" + direction](), childNode);
	        }
	    };
	    D2tree.prototype._calculateDistance = function (marker, coords) {
	        // if this branch doesn't exist
	        if (!marker) return Infinity;
	        // else calculate
	        // console.log(`lat1: ${marker.getLat()}; lat2: ${coords.lat}`);
	        // console.log(`lng1: ${marker.getLng()}; lng2: ${coords.lng}`);
	        // console.log(`dist ${Math.sqrt(
	        //             Math.pow(marker.getLat() - coords.lat, 2) +
	        //             Math.pow(marker.getLng() - coords.lng, 2)
	        //         )}`);
	        return Math.sqrt(Math.pow(marker.getLat() - coords.lat, 2) + Math.pow(marker.getLng() - coords.lng, 2));
	    };
	    D2tree.prototype.addLeaf = function (coords, content) {
	        // create new Node
	        var newLeaf = new Node(coords, content);
	        // and insert it
	        this._place(this._root, newLeaf);
	    };
	    /** return array of content! of all nodes in top to bottom, left to right order */
	    D2tree.prototype.traverse = function () {
	        var output;
	        output = [this._root];
	        // this._root.getValue()[0].bindLabel(this._root.getValue()[1]+': -1', { noHide: true });
	        var i = 0;
	        var tempNode;
	        while (i < output.length) {
	            if (output[i]) {
	                tempNode = output[i].getLeftNode();
	                if (tempNode) {
	                    // tempNode.getValue()[0].bindLabel(tempNode.getValue()[1]+': '+i, { noHide: true });
	                    output.push(tempNode);
	                }
	                tempNode = output[i].getRightNode();
	                if (tempNode) {
	                    // tempNode.getValue()[0].bindLabel(tempNode.getValue()[1]+': '+i, { noHide: true });
	                    output.push(tempNode);
	                }
	            }
	            i++;
	        }
	        return output.map(function (e) {
	            return e.getContent();
	        });
	    };
	    D2tree.prototype.getRoot = function () {
	        return this._root;
	    };
	    /*** find nearest node to the specified point
	     * @return : {content: it's content, dist: distance  in [deg]}
	    */
	    D2tree.prototype.findNearest = function (coords) {
	        var self = this;
	        var tempLeader;
	        var beingChecked = this._root;
	        var notChecked = [];
	        var now, later;
	        var dist = {
	            Left: -1,
	            Right: -1,
	            leader: -1
	        };
	        dist.leader = this._calculateDistance(beingChecked, coords);
	        tempLeader = beingChecked;
	        var searchDeeper = function () {
	            var tempDirection;
	            if (beingChecked.getColor()) {
	                // RED - lng
	                if (beingChecked.getLng() <= coords.lng) {
	                    // go to the right
	                    dist.Right = self._calculateDistance(beingChecked.getRightNode(), coords);
	                    if (dist.Right < dist.leader) {
	                        // new leader
	                        tempLeader = beingChecked.getRightNode();
	                        dist.leader = dist.Right;
	                        if (beingChecked.getLat() >= beingChecked.getRightNode().getLat() && beingChecked.getLat() <= coords.lat || beingChecked.getLat() <= beingChecked.getRightNode().getLat() && beingChecked.getLat() >= coords.lat) {
	                            // moving in different direction from the point of interest, consider the possibility going left later
	                            notChecked.push(beingChecked.getLeftNode());
	                        }
	                    } else {
	                        // definitely consider the possibility going left later
	                        notChecked.push(beingChecked.getLeftNode());
	                    }
	                    // proceed search in the right branch
	                    beingChecked = beingChecked.getRightNode();
	                } else {
	                    // go to the left
	                    dist.Left = self._calculateDistance(beingChecked.getLeftNode(), coords);
	                    if (dist.Left < dist.leader) {
	                        // new leader
	                        tempLeader = beingChecked.getLeftNode();
	                        dist.leader = dist.Left;
	                        if (beingChecked.getLat() >= beingChecked.getLeftNode().getLat() && beingChecked.getLat() <= coords.lat || beingChecked.getLat() <= beingChecked.getLeftNode().getLat() && beingChecked.getLat() >= coords.lat) {
	                            // moving in different direction from the point of interest, consider the possibility going right later
	                            notChecked.push(beingChecked.getRightNode());
	                        }
	                    } else {
	                        // definitely consider the possibility going right later
	                        notChecked.push(beingChecked.getRightNode());
	                    }
	                    // proceed search in the left branch
	                    beingChecked = beingChecked.getLeftNode();
	                }
	            } else {
	                // BLACK - lat
	                if (beingChecked.getLat() <= coords.lat) {
	                    // go to the right
	                    dist.Right = self._calculateDistance(beingChecked.getRightNode(), coords);
	                    if (dist.Right < dist.leader) {
	                        // new leader
	                        tempLeader = beingChecked.getRightNode();
	                        dist.leader = dist.Right;
	                        if (beingChecked.getLng() >= beingChecked.getRightNode().getLng() && beingChecked.getLng() <= coords.lng || beingChecked.getLng() <= beingChecked.getRightNode().getLng() && beingChecked.getLng() >= coords.lng) {
	                            // moving in different direction from the point of interest, consider the possibility going left later
	                            notChecked.push(beingChecked.getLeftNode());
	                        }
	                    } else {
	                        // definitely consider the possibility going right later
	                        notChecked.push(beingChecked.getLeftNode());
	                    }
	                    // proceed search in the right branch
	                    beingChecked = beingChecked.getRightNode();
	                } else {
	                    // go to the left
	                    dist.Left = self._calculateDistance(beingChecked.getLeftNode(), coords);
	                    if (dist.Left < dist.leader) {
	                        // new leader
	                        tempLeader = beingChecked.getLeftNode();
	                        dist.leader = dist.Left;
	                        if (beingChecked.getLng() >= beingChecked.getLeftNode().getLng() && beingChecked.getLng() <= coords.lng || beingChecked.getLng() <= beingChecked.getLeftNode().getLng() && beingChecked.getLng() >= coords.lng) {
	                            // moving in different direction from the point of interest, consider the possibility going right later
	                            notChecked.push(beingChecked.getRightNode());
	                        }
	                    } else {
	                        // definitely consider the possibility going right later
	                        notChecked.push(beingChecked.getRightNode());
	                    }
	                    // proceed search in the left branch
	                    beingChecked = beingChecked.getLeftNode();
	                }
	            }
	        };
	        // iterate while there is where to go deeper or where to return on the other branches
	        while (beingChecked || notChecked.length) {
	            if (beingChecked) searchDeeper();else beingChecked = notChecked.pop();
	        }
	        return {
	            dist: dist.leader,
	            content: tempLeader.getContent()
	        };
	        // test._baseMarkersTree._calculateDistance({lat:54.9830,lng:82.8722},0.001)
	    };
	    return D2tree;
	}();
	exports.D2tree = D2tree;

/***/ }
/******/ ]);
//# sourceMappingURL=app.min.js.map