var app =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="./../../typings/tsd.d.ts" />
	"use strict";
	/* global L, document, XMLHttpRequest */
	
	var D2tree_ts_1 = __webpack_require__(1);
	var markerAggregator_ts_1 = __webpack_require__(2);
	var map;
	var test;
	(function (context) {
	    'use strict';
	    // calculate markers center
	
	    var avgLat = 0,
	        avgLng = 0;
	    for (var i = 0; i < points.length; i++) {
	        avgLat += +points[i].lat;
	        avgLng += +points[i].lng;
	    }
	    avgLat /= points.length;
	    avgLng /= points.length;
	    document.addEventListener('DOMContentLoaded', function () {
	        // display map
	        map = L.map('map').setView([avgLat, avgLng], 12);
	        L.tileLayer.provider('OpenStreetMap.HOT').addTo(map);
	        // instantiate aggregator
	        test = new markerAggregator_ts_1.MarkerAggregator(map, {});
	        var tree = new D2tree_ts_1.D2tree({ lat: points[0].lat, lng: points[0].lng }, [L.marker([points[0].lat, points[0].lng]), 0]);
	        // for (var i=1; i < points.length; i++) {
	        //     test.addMarker({lat: points[i].lat, lng: points[i].lng});
	        //     // tree.addLeaf({lat: points[i].lat, lng: points[i].lng}, [L.marker([points[i].lat, points[i].lng]),i]);
	        //     // L.marker([points[i].lat, points[i].lng]).bindLabel(''+i, { noHide: true }).addTo(map);
	        // }
	        // var q = test.getBaseMarkers();
	        // console.log(q);
	        var j = 0;
	        document.addEventListener('click', function () {
	            console.log(j);
	            // if (j < q.length) {
	            //     if (q[j]) q[j].marker.addTo(map);
	            // } else {alert('q');}
	            // j++;
	            if (j < points.length) {
	                test.addMarker({ lat: points[j].lat, lng: points[j].lng });
	                j++;
	            }
	        });
	        // for (var j=0; j < q.length; j++) {
	        //     // if (q[j]) console.log(q[j].getValue()[0]);
	        //     if (q[j]) q[j].marker.addTo(map);
	        // }
	        // test.start();
	        // console.log(test.getBaseMarkers());
	        context.tree = tree;
	        context.test = test;
	        context.map = map;
	    });
	})(window);

/***/ },
/* 1 */
/***/ function(module, exports) {

	/// <reference path="./../../typings/tsd.d.ts" />
	"use strict";
	
	var Node = function () {
	    function Node(coords, marker) {
	        // coords either Ilatlng or [lat, lng]
	        // read coordinates
	        if (Array.isArray(coords) && coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
	            this._latKey = coords[0];
	            this._lngKey = coords[1];
	        } else if ((coords.lat || coords.lat === 0) && (coords.lng || coords.lng === 0)) {
	            this._latKey = coords.lat;
	            this._lngKey = coords.lng;
	        } else {
	            console.error('D2tree - Node: wrong node coordinates');
	            this._latKey = 0;
	            this._lngKey = 0;
	        }
	        // no branches
	        this._leftNode = null;
	        this._rightNode = null;
	        // by default red
	        this._color = true;
	        this._content = marker;
	    }
	    Node.prototype.setLeftNode = function (node) {
	        this._leftNode = node;
	        return this._leftNode;
	    };
	    Node.prototype.setRightNode = function (node) {
	        this._rightNode = node;
	        return this._rightNode;
	    };
	    Node.prototype.getLeftNode = function () {
	        return this._leftNode;
	    };
	    Node.prototype.getRightNode = function () {
	        return this._rightNode;
	    };
	    Node.prototype.setColor = function (color) {
	        if (color) this._color = true;else this._color = false;
	    };
	    Node.prototype.getColor = function () {
	        return this._color;
	    };
	    Node.prototype.getLat = function () {
	        return this._latKey;
	    };
	    Node.prototype.getLng = function () {
	        return this._lngKey;
	    };
	    Node.prototype.getContent = function () {
	        return this._content;
	    };
	    return Node;
	}();
	var D2tree = function () {
	    function D2tree(coords, content) {
	        this._root = new Node(coords, content);
	    }
	    D2tree.prototype._place = function (parentNode, childNode) {
	        var method;
	        var direction;
	        if (parentNode.getColor()) {
	            // RED - lng
	            method = 'getLng';
	        } else {
	            // BLACK - lat
	            method = 'getLat';
	        }
	        if (parentNode[method]() < childNode[method]()) {
	            // new to right
	            direction = 'RightNode';
	        } else {
	            // new to left
	            direction = 'LeftNode';
	        }
	        if (!parentNode["get" + direction]()) {
	            // branch is empty
	            parentNode["set" + direction](childNode);
	            parentNode["get" + direction]().setColor(!parentNode.getColor());
	        } else {
	            this._place(parentNode["get" + direction](), childNode);
	        }
	    };
	    D2tree.prototype._calculateDistance = function (marker, coords) {
	        // if this branch doesn't exist
	        if (!marker) return Infinity;
	        // else calculate
	        return Math.sqrt(Math.pow(marker.getLat() - coords.lat, 2) + Math.pow(marker.getLng() - coords.lng, 2));
	    };
	    D2tree.prototype.addLeaf = function (coords, content) {
	        // create new Node
	        var newLeaf = new Node(coords, content);
	        // and insert it
	        this._place(this._root, newLeaf);
	    };
	    /** return array of content! of all nodes in top to bottom, left to right order */
	    D2tree.prototype.traverse = function () {
	        var output;
	        output = [this._root];
	        // this._root.getValue()[0].bindLabel(this._root.getValue()[1]+': -1', { noHide: true });
	        var i = 0;
	        var tempNode;
	        while (i < output.length) {
	            if (output[i]) {
	                tempNode = output[i].getLeftNode();
	                if (tempNode) {
	                    // tempNode.getValue()[0].bindLabel(tempNode.getValue()[1]+': '+i, { noHide: true });
	                    output.push(tempNode);
	                }
	                tempNode = output[i].getRightNode();
	                if (tempNode) {
	                    // tempNode.getValue()[0].bindLabel(tempNode.getValue()[1]+': '+i, { noHide: true });
	                    output.push(tempNode);
	                }
	            }
	            i++;
	        }
	        return output.map(function (e) {
	            return e.getContent();
	        });
	    };
	    D2tree.prototype.getRoot = function () {
	        return this._root;
	    };
	    /*** find nearest node to the specified point
	     * @return : {content: it's content, dist: distance  in [deg]}
	    */
	    D2tree.prototype.findNearest = function (coords) {
	        var self = this;
	        var tempLeader;
	        var beingChecked = this._root;
	        var notChecked = [];
	        var now, later;
	        var dist = {
	            Left: -1,
	            Right: -1,
	            leader: -1
	        };
	        dist.leader = this._calculateDistance(beingChecked, coords);
	        tempLeader = beingChecked;
	        var searchDeeper = function () {
	            dist.Left = self._calculateDistance(beingChecked.getLeftNode(), coords);
	            dist.Right = self._calculateDistance(beingChecked.getRightNode(), coords);
	            if (dist.Left < dist.Right) {
	                // now = 'Left';
	                // later = 'Right';
	                if (dist.Left < dist.leader) {
	                    dist.leader = dist.Left;
	                    tempLeader = beingChecked.getLeftNode();
	                } else if (beingChecked && beingChecked.getRightNode()) {
	                    // haven't got closer -> possibility that there is one closer on the other branch; if it's not null
	                    notChecked.push(beingChecked.getRightNode());
	                }
	                // move deeper
	                beingChecked = beingChecked.getLeftNode();
	            } else {
	                // now = 'Right';
	                // later = 'Left';
	                if (dist.Right < dist.leader) {
	                    dist.leader = dist.Right;
	                    tempLeader = beingChecked.getRightNode();
	                } else if (beingChecked && beingChecked.getLeftNode()) {
	                    // haven't got closer -> possibility that there is one closer on the other branch; if it's not null
	                    notChecked.push(beingChecked.getLeftNode());
	                }
	                // move deeper
	                beingChecked = beingChecked.getRightNode();
	            }
	            // if (dist[now] < dist.leader) {
	            //     dist.leader = dist[now];
	            //     tempLeader = beingChecked[`get${now}Node`]();
	            // } else if (beingChecked && beingChecked[`get${later}Node`]()) {
	            //     // haven't got closer -> possibility that there is one closer on the other branch; if it's not null
	            //     notChecked.push(beingChecked[`get${later}Node`]());
	            // }
	            // // move deeper
	            // beingChecked = beingChecked[`get${now}Node`]();
	        };
	        // iterate while there is where to go deeper or where to return on the other branches
	        while (beingChecked || notChecked.length) {
	            if (beingChecked) searchDeeper();else beingChecked = notChecked.pop();
	        }
	        return {
	            dist: dist.leader,
	            content: tempLeader.getContent()
	        };
	        // test._baseMarkersTree._calculateDistance({lat:54.9830,lng:82.8722},0.001)
	    };
	    return D2tree;
	}();
	exports.D2tree = D2tree;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="./../../typings/tsd.d.ts" />
	/* global L */
	"use strict";
	
	var D2tree_ts_1 = __webpack_require__(1);
	// (function(context){
	// 'use strict';
	var MarkerAggregator = function () {
	    function MarkerAggregator(map, options) {
	        // assume L to be a global var
	        if (!L.version) console.error('Can\'t find Leaflet library');
	        if (options) {
	            this._map = map;
	            this._baseZoom = options.baseZoom || 15;
	            this._zoomStep = options.zoomStep || 1;
	            this._minZoom = options.minZoom || 7;
	            this._minZoom = this._baseZoom - (this._baseZoom - this._minZoom) / 2 * 2;
	            this._baseWindowSize = options.baseWindowSize || 0.005;
	        }
	        this._id = 0;
	        this._eastSouth = null;
	        // this._baseMarkers = [];
	        this._baseMarkersTree = null;
	        this._zoomLevels = [];
	        for (var j = this._baseZoom; j >= this._minZoom; j -= this._zoomStep) {
	            console.log(j);
	            this._zoomLevels[j] = {
	                windowSize: this._baseWindowSize * Math.pow(1.7, this._baseZoom - j),
	                // markers: {},
	                compositeMarkersTree: null
	            };
	        }
	        this._setCurrentZoomLevel();
	    }
	    /*** calculate what set of markers (zoomLevel) to display based on the current map zoom */
	    MarkerAggregator.prototype._setCurrentZoomLevel = function () {
	        var mapZoom = this._map.getZoom();
	        if (mapZoom <= this._minZoom) {
	            this._currentZoomLevel = this._minZoom;
	        } else if (mapZoom >= this._baseZoom) {
	            this._currentZoomLevel = this._baseZoom;
	        } else {
	            this._currentZoomLevel = this._baseZoom - Math.floor((this._baseZoom - mapZoom) / 2) * 2;
	        }
	    };
	    /*** when first marker is added iterate over all zoom levels and create trees
	     * to minimize computing expenses don't recalculate composite marker position
	     * just change it's content - if there is no base markers in it make it null
	    */
	    MarkerAggregator.prototype._createCompositeMarkers = function (coords, baseMarker) {
	        var baseZoom = this._baseZoom,
	            zoomStep = this._zoomStep,
	            minZoom = this._minZoom,
	            zoomLevels = this._zoomLevels;
	        // apply changes to corresponding composite markers
	        var latIndex, lngIndex;
	        var compositeMarkerRef;
	        var nearest;
	        // for every zoom level
	        // for (var j=baseZoom; j >= minZoom; j-=zoomStep) {
	        for (var j = 12; j === 12; j++) {
	            // console.log(zoomLevels[j]);
	            if (!zoomLevels[j].compositeMarkersTree) {
	                // no composites yet
	                zoomLevels[j].compositeMarkersTree = new D2tree_ts_1.D2tree(coords, baseMarker);
	                baseMarker.marker.addTo(this._map);
	            } else {
	                // search for the nearest composite on this zoom level
	                // within the radius of windowSize
	                nearest = zoomLevels[j].compositeMarkersTree.findNearest(baseMarker.marker.getLatLng());
	                console.log(zoomLevels[j].windowSize);
	                console.log(nearest);
	                if (nearest.dist <= zoomLevels[j].windowSize) {
	                    // if exists, add add new base marker to it
	                    // implement
	                    var greenIcon = L.icon({
	                        iconUrl: 'trash/leaf-green.png',
	                        shadowUrl: 'trash/leaf-shadow.png',
	                        iconSize: [38, 95],
	                        shadowSize: [50, 64],
	                        iconAnchor: [22, 94],
	                        shadowAnchor: [4, 62],
	                        popupAnchor: [-3, -76] // point from which the popup should open relative to the iconAnchor
	                    });
	                    baseMarker.marker.setIcon(greenIcon).addTo(this._map);
	                } else {
	                    // if not, create new   
	                    zoomLevels[j].compositeMarkersTree.addLeaf(coords, baseMarker);
	                    baseMarker.marker.addTo(this._map);
	                }
	            }
	        }
	    };
	    // public addMarker (coords: any): number {
	    /*** add new leaflet marker to the aggregator
	     * @marker - leaflet marker object
	     * @return - number of base markers if successful, -1 if not
	     * because it uses eastern-southern point as a reference, it's better to start adding markers from
	     * the most easter and most southern markers to prevent general recalculation
	    */
	    MarkerAggregator.prototype.addMarker = function (coords) {
	        var localCoords = { lat: 0, lng: 0 };
	        // read coordinates
	        if (Array.isArray(coords) && coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
	            localCoords.lat = coords[0];
	            localCoords.lng = coords[1];
	        } else if ((coords.lat || coords.lat === 0) && (coords.lng || coords.lng === 0)) {
	            localCoords.lat = coords.lat;
	            localCoords.lng = coords.lng;
	        } else {
	            return -1;
	        }
	        // create leaf content - marker
	        var marker = {
	            marker: L.marker([localCoords.lat, localCoords.lng]),
	            aId: ++this._id
	        };
	        // this._baseMarkers.push(marker);
	        // this tree of no use now, maybee for the future
	        // if it's the first marker inserted
	        if (!this._baseMarkersTree) {
	            this._baseMarkersTree = new D2tree_ts_1.D2tree(localCoords, marker);
	        } else {
	            this._baseMarkersTree.addLeaf(localCoords, marker);
	        }
	        this._createCompositeMarkers(localCoords, marker);
	        // var basePointShift = false;
	        // // calculate center using the first one
	        // if (!this._eastSouth) {
	        // 	this._eastSouth = {
	        // 		lat: localCoords.lat - 0.00001,
	        // 		lng: localCoords.lng + 0.00001
	        // 	}
	        // } else if (this._eastSouth.lat >= localCoords.lat) {
	        // 	// new base point
	        // 	this._eastSouth.lat = localCoords.lat - 0.00001;
	        // 	basePointShift = true;
	        // } else if (this._eastSouth.lng <= localCoords.lng) {
	        // 	// -//-
	        // 	this._eastSouth.lng = localCoords.lng + 0.00001;
	        // 	basePointShift = true;
	        // }
	        // if (basePointShift) {
	        // 	// recalculate everything
	        // 	// remove composite markers
	        // 	for (var j=this._baseZoom-this._zoomStep; j>=this._minZoom; j-=this._zoomStep) {
	        // 		// markers on the current zoom layer (currently displayed) from the map
	        // 		if (j === this._currentZoomLevel) {
	        // 			for (var k in this._zoomLevels[''+j].markers) {
	        // 				this._map.removeLayer(this._zoomLevels[''+j].markers[k].marker);	
	        // 			}
	        // 		}
	        // 		// from _zoomLevels
	        // 		this._zoomLevels[''+j] = {
	        // 			windowSize: this._baseWindowSize * Math.pow(1.7, this._baseZoom - j),
	        // 			markers: {}
	        // 		};
	        // 	}
	        // 	// remove links to them from base markers
	        // 	// for every existing base marker recalculate composite
	        // 	for (var j=0; j<this._baseMarkers.length; j++) {
	        // 		this.createCompositeMarkers(this._baseMarkers[j]);
	        // 	}
	        // } else {
	        // 	// just add composite markers including given base marker
	        // 	this.createCompositeMarkers(baseMarkerRef);	
	        // }
	        // if (this._currentZoomLevel === this._baseZoom) {
	        // 	// display base marker
	        // 	baseMarkerRef.addTo(this._map);
	        // }
	        // // return new base marker id
	        // return baseMarkerRef.aId;
	        return 0;
	    };
	    /*** return base markers */
	    MarkerAggregator.prototype.getBaseMarkers = function () {
	        return this._baseMarkersTree.traverse();
	    };
	    /*** redraw markers on the map */
	    MarkerAggregator.prototype._rerender = function () {
	        console.log('inside rerender');
	        var tmpLMarkers;
	        var j;
	        // store old zoom level and calculate new one
	        var oldZoom = this._currentZoomLevel;
	        this._setCurrentZoomLevel();
	        if (this._zoomLevels[this._currentZoomLevel] && this._zoomLevels[this._currentZoomLevel] !== this._zoomLevels[oldZoom]) {
	            // if new zoom level exists and is not the same as the previous
	            tmpLMarkers = this._zoomLevels[oldZoom].compositeMarkersTree.traverse();
	            // remove old markers from the map
	            for (j = 0; j < tmpLMarkers.length; j++) {
	                this._map.removeLayer(tmpLMarkers[j].marker);
	            }
	            tmpLMarkers = this._zoomLevels[this._currentZoomLevel].compositeMarkersTree.traverse();
	            // add new markers
	            for (j = 0; j < tmpLMarkers.length; j++) {
	                tmpLMarkers[j].marker.addTo(this._map);
	            }
	        }
	        //                 this._zoomLevels[oldZoom];
	        // 				// var i;
	        // 				this._setCurrentZoomLevel();
	        // console.log(this._zoomLevels[oldZoom].compositeMarkersTree.traverse());
	        // console.log(this._zoomLevels[this._currentZoomLevel].compositeMarkersTree.traverse());
	        // if (oldZoom !== self._currentZoomLevel) {
	        // 	// need to display different group of markers
	        // 	// hide old
	        // 	if (oldZoom === self._baseZoom) {
	        // 		// hide base markers
	        // 		for (i=0; i<self._baseMarkers.length; i++) {
	        // 			self._map.removeLayer(self._baseMarkers[i]);
	        // 		}
	        // 	} else {
	        // 		// hide composite markers
	        // 		for (var key in self._zoomLevels[''+oldZoom].markers) {
	        // 			self._map.removeLayer(self._zoomLevels[''+oldZoom].markers[key].marker);
	        // 		}
	        // 	}		
	        // 	// display new
	        // 	if (self._zoomLevels[''+self._currentZoomLevel]) {
	        // 		// composite markers
	        // 		for (var key in self._zoomLevels[''+self._currentZoomLevel].markers) {
	        // 			self._zoomLevels[''+self._currentZoomLevel].markers[key].marker.addTo(self._map);
	        // 		}
	        // 	} else {
	        // 		// base markers
	        // 		for (i=0; i<self._baseMarkers.length; i++) {
	        // 			self._baseMarkers[i].addTo(self._map);
	        // 		}
	        // 	}
	        // }
	    };
	    /*** start listen for map's zoom change */
	    MarkerAggregator.prototype.start = function () {
	        // take care not to call rerender many times
	        this.stop();
	        console.log('inside start');
	        this._map.on('zoomend', this._rerender, this);
	        // initialize
	        this._rerender();
	    };
	    /*** stop listen for map's zoom change */
	    MarkerAggregator.prototype.stop = function () {
	        console.log('inside stop');
	        this._map.off('zoomend', this._rerender, this);
	    };
	    return MarkerAggregator;
	}();
	exports.MarkerAggregator = MarkerAggregator;
	// inject
	// 	context.MarkerAggregator = MarkerAggregator;
	// }(window));

/***/ }
/******/ ]);
//# sourceMappingURL=app.min.js.map